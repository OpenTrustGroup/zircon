// Copyright 2018 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "fidl/c_generator.h"

#include "fidl/attributes.h"
#include "fidl/names.h"

namespace fidl {

namespace {

// Various string values are looked up or computed in these
// functions. Nothing else should be dealing in string literals, or
// computing strings from these or AST values.

constexpr const char* kIndent = "    ";

CGenerator::Member MessageHeader() {
    return {"fidl_message_header_t", "hdr", {}};
}

// Functions named "Emit..." are called to actually emit to an std::ostream
// is here. No other functions should directly emit to the streams.

std::ostream& operator<<(std::ostream& stream, StringView view) {
    stream.rdbuf()->sputn(view.data(), view.size());
    return stream;
}

void EmitFileComment(std::ostream* file) {
    *file << "// WARNING: This file is machine generated by fidlc.\n\n";
}

void EmitHeaderGuard(std::ostream* file) {
    // TODO(704) Generate an appropriate header guard name.
    *file << "#pragma once\n";
}

void EmitIncludeHeader(std::ostream* file, StringView header) {
    *file << "#include " << header << "\n";
}

void EmitBeginExternC(std::ostream* file) {
    *file << "#if defined(__cplusplus)\nextern \"C\" {\n#endif\n";
}

void EmitEndExternC(std::ostream* file) {
    *file << "#if defined(__cplusplus)\n}\n#endif\n";
}

void EmitBlank(std::ostream* file) {
    *file << "\n";
}

void EmitMemberDecl(std::ostream* file, const CGenerator::Member& member) {
    *file << member.type << " " << member.name;
    for (uint32_t array_count : member.array_counts) {
        *file << "[" << array_count << "]";
    }
}

void EmitClientMethodDecl(std::ostream* file, StringView method_name,
                          const std::vector<CGenerator::Member>& request,
                          const std::vector<CGenerator::Member>& response) {
    *file << "zx_status_t " << method_name << "(zx_handle_t _channel";
    for (const auto& member : request) {
        *file << ", ";
        EmitMemberDecl(file, member);
    }
    for (auto member : response) {
        *file << ", ";
        member.name = "out_" + member.name;
        EmitMemberDecl(file, member);
    }
    *file << ")";
}

// Various computational helper routines.

void EnumValue(types::PrimitiveSubtype type, const flat::Constant* constant,
               const flat::Library* library, std::string* out_value) {
    // TODO(kulakowski) Move this into library resolution.

    std::ostringstream member_value;

    switch (type) {
    case types::PrimitiveSubtype::kInt8: {
        int8_t value;
        bool success = library->ParseIntegerConstant(constant, &value);
        if (!success) {
            __builtin_trap();
        }
        // The char-sized overloads of operator<< here print
        // the character value, not the numeric value, so cast up.
        member_value << static_cast<int>(value);
        break;
    }
    case types::PrimitiveSubtype::kInt16: {
        int16_t value;
        bool success = library->ParseIntegerConstant(constant, &value);
        if (!success) {
            __builtin_trap();
        }
        member_value << value;
        break;
    }
    case types::PrimitiveSubtype::kInt32: {
        int32_t value;
        bool success = library->ParseIntegerConstant(constant, &value);
        if (!success) {
            __builtin_trap();
        }
        member_value << value;
        break;
    }
    case types::PrimitiveSubtype::kInt64: {
        int64_t value;
        bool success = library->ParseIntegerConstant(constant, &value);
        if (!success) {
            __builtin_trap();
        }
        member_value << value;
        break;
    }
    case types::PrimitiveSubtype::kUint8: {
        uint8_t value;
        bool success = library->ParseIntegerConstant(constant, &value);
        if (!success) {
            __builtin_trap();
        }
        // The char-sized overloads of operator<< here print
        // the character value, not the numeric value, so cast up.
        member_value << static_cast<unsigned int>(value);
        break;
    }
    case types::PrimitiveSubtype::kUint16: {
        uint16_t value;
        bool success = library->ParseIntegerConstant(constant, &value);
        if (!success) {
            __builtin_trap();
        }
        member_value << value;
        break;
    }
    case types::PrimitiveSubtype::kUint32: {
        uint32_t value;
        bool success = library->ParseIntegerConstant(constant, &value);
        if (!success) {
            __builtin_trap();
        }
        member_value << value;
        break;
    }
    case types::PrimitiveSubtype::kUint64: {
        uint64_t value;
        bool success = library->ParseIntegerConstant(constant, &value);
        if (!success) {
            __builtin_trap();
        }
        member_value << value;
        break;
    }
    case types::PrimitiveSubtype::kBool:
    case types::PrimitiveSubtype::kStatus:
    case types::PrimitiveSubtype::kFloat32:
    case types::PrimitiveSubtype::kFloat64:
        assert(false && "bad primitive type for an enum");
        break;
    }

    *out_value = member_value.str();
}

std::vector<uint32_t> ArrayCounts(const flat::Library* library, const flat::Type* type) {
    std::vector<uint32_t> array_counts;
    for (;;) {
        switch (type->kind) {
        default: { return array_counts; }
        case flat::Type::Kind::kArray: {
            auto array_type = static_cast<const flat::ArrayType*>(type);
            uint32_t element_count = array_type->element_count.Value();
            array_counts.push_back(element_count);
            type = array_type->element_type.get();
            continue;
        }
        }
    }
}

template <typename T, std::string NameType(const flat::Type*) = NameFlatCType>
CGenerator::Member CreateMember(const flat::Library* library, const T& decl) {
    std::string name = NameIdentifier(decl.name);
    const flat::Type* type = decl.type.get();
    auto type_name = NameType(type);
    std::vector<uint32_t> array_counts = ArrayCounts(library, type);
    return CGenerator::Member{type_name, name, std::move(array_counts)};
}

std::vector<CGenerator::Member>
GenerateMembers(const flat::Library* library,
                const std::vector<flat::Union::Member>& union_members) {
    std::vector<CGenerator::Member> members;
    members.reserve(union_members.size());
    for (const auto& union_member : union_members) {
        members.push_back(CreateMember(library, union_member));
    }
    return members;
}

void GetMethodParameters(const flat::Library* library,
                         const CGenerator::NamedMethod& method_info,
                         std::vector<CGenerator::Member>* request,
                         std::vector<CGenerator::Member>* response) {

    request->reserve(method_info.request->parameters.size());
    for (const auto& parameter : method_info.request->parameters) {
        request->push_back(CreateMember(library, parameter));
    }

    if (method_info.response) {
        response->reserve(method_info.request->parameters.size());
        for (const auto& parameter : method_info.response->parameters) {
            response->push_back(CreateMember<flat::Interface::Method::Parameter, NameFlatCOutType>(library, parameter));
        }
    }
}

} // namespace

void CGenerator::GeneratePrologues() {
    EmitFileComment(&file_);
    EmitHeaderGuard(&file_);
    EmitBlank(&file_);
    EmitIncludeHeader(&file_, "<stdalign.h>");
    EmitIncludeHeader(&file_, "<stdbool.h>");
    EmitIncludeHeader(&file_, "<stdint.h>");
    EmitIncludeHeader(&file_, "<zircon/fidl.h>");
    EmitIncludeHeader(&file_, "<zircon/syscalls/object.h>");
    EmitIncludeHeader(&file_, "<zircon/types.h>");
    for (const auto& pair : *library_->dependencies_) {
        if (pair.second.get() == library_)
            continue;
        EmitIncludeHeader(&file_, "<" + NameLibraryCHeader(pair.first) + ">");
    }
    EmitBlank(&file_);
    EmitBeginExternC(&file_);
    EmitBlank(&file_);
}

void CGenerator::GenerateEpilogues() {
    EmitEndExternC(&file_);
}

void CGenerator::GenerateIntegerDefine(StringView name, types::PrimitiveSubtype subtype,
                                       StringView value) {
    std::string literal_macro = NamePrimitiveIntegerCConstantMacro(subtype);
    file_ << "#define " << name << " " << literal_macro << "(" << value << ")\n";
}

void CGenerator::GenerateIntegerTypedef(types::PrimitiveSubtype subtype, StringView name) {
    std::string underlying_type = NamePrimitiveCType(subtype);
    file_ << "typedef " << underlying_type << " " << name << ";\n";
}

void CGenerator::GenerateStructTypedef(StringView name) {
    file_ << "typedef struct " << name << " " << name << ";\n";
}

void CGenerator::GenerateStructDeclaration(StringView name, const std::vector<Member>& members) {
    file_ << "struct " << name << " {\n";
    file_ << kIndent << "FIDL_ALIGNDECL\n";
    for (const auto& member : members) {
        file_ << kIndent;
        EmitMemberDecl(&file_, member);
        file_ << ";\n";
    }
    file_ << "};\n";
}

void CGenerator::GenerateTaggedUnionDeclaration(StringView name,
                                                const std::vector<Member>& members) {
    file_ << "struct " << name << " {\n";
    file_ << kIndent << "FIDL_ALIGNDECL\n";
    file_ << kIndent << "fidl_union_tag_t tag;\n";
    file_ << kIndent << "union {\n";
    for (const auto& member : members) {
        file_ << kIndent << kIndent;
        EmitMemberDecl(&file_, member);
        file_ << ";\n";
    }
    file_ << kIndent << "};\n";
    file_ << "};\n";
}

// TODO(TO-702) These should maybe check for global name
// collisions? Otherwise, is there some other way they should fail?
std::map<const flat::Decl*, CGenerator::NamedConst>
CGenerator::NameConsts(const std::vector<std::unique_ptr<flat::Const>>& const_infos) {
    std::map<const flat::Decl*, NamedConst> named_consts;
    for (const auto& const_info : const_infos) {
        named_consts.emplace(const_info.get(), NamedConst{"", *const_info});
    }
    return named_consts;
}

std::map<const flat::Decl*, CGenerator::NamedEnum>
CGenerator::NameEnums(const std::vector<std::unique_ptr<flat::Enum>>& enum_infos) {
    std::map<const flat::Decl*, NamedEnum> named_enums;
    for (const auto& enum_info : enum_infos) {
        std::string enum_name = NameName(enum_info->name, "_", "_");
        named_enums.emplace(enum_info.get(), NamedEnum{std::move(enum_name), *enum_info});
    }
    return named_enums;
}

std::map<const flat::Decl*, CGenerator::NamedInterface>
CGenerator::NameInterfaces(const std::vector<std::unique_ptr<flat::Interface>>& interface_infos) {
    std::map<const flat::Decl*, NamedInterface> named_interfaces;
    for (const auto& interface_info : interface_infos) {
        NamedInterface named_interface;
        std::string interface_name = NameInterface(*interface_info);
        for (const auto& method : interface_info->methods) {
            NamedMethod named_method;
            std::string method_name = NameMethod(interface_name, method);
            named_method.ordinal = method.ordinal.Value();
            named_method.ordinal_name = NameOrdinal(method_name);
            named_method.c_name = method_name;
            if (method.maybe_request != nullptr) {
                std::string c_name = NameMessage(method_name, types::MessageKind::kRequest);
                std::string coded_name = NameTable(c_name);
                named_method.request = std::make_unique<NamedMessage>(NamedMessage{
                    std::move(c_name), std::move(coded_name), method.maybe_request->parameters});
            }
            if (method.maybe_response != nullptr) {
                if (method.maybe_request == nullptr) {
                    std::string c_name =
                        NameMessage(method_name, types::MessageKind::kEvent);
                    std::string coded_name = NameTable(c_name);
                    named_method.response = std::make_unique<NamedMessage>(
                        NamedMessage{std::move(c_name), std::move(coded_name),
                                     method.maybe_response->parameters});
                } else {
                    std::string c_name = NameMessage(method_name, types::MessageKind::kResponse);
                    std::string coded_name = NameTable(c_name);
                    named_method.response = std::make_unique<NamedMessage>(
                        NamedMessage{std::move(c_name), std::move(coded_name),
                                     method.maybe_response->parameters});
                }
            }
            named_interface.methods.push_back(std::move(named_method));
        }
        named_interfaces.emplace(interface_info.get(), std::move(named_interface));
    }
    return named_interfaces;
}

std::map<const flat::Decl*, CGenerator::NamedStruct>
CGenerator::NameStructs(const std::vector<std::unique_ptr<flat::Struct>>& struct_infos) {
    std::map<const flat::Decl*, NamedStruct> named_structs;
    for (const auto& struct_info : struct_infos) {
        std::string c_name = NameName(struct_info->name, "_", "_");
        std::string coded_name = c_name + "Coded";
        named_structs.emplace(struct_info.get(),
                              NamedStruct{std::move(c_name), std::move(coded_name), *struct_info});
    }
    return named_structs;
}

std::map<const flat::Decl*, CGenerator::NamedUnion>
CGenerator::NameUnions(const std::vector<std::unique_ptr<flat::Union>>& union_infos) {
    std::map<const flat::Decl*, NamedUnion> named_unions;
    for (const auto& union_info : union_infos) {
        std::string union_name = NameName(union_info->name, "_", "_");
        named_unions.emplace(union_info.get(), NamedUnion{std::move(union_name), *union_info});
    }
    return named_unions;
}

void CGenerator::ProduceConstForwardDeclaration(const NamedConst& named_const) {
    // TODO(TO-702)
}

void CGenerator::ProduceEnumForwardDeclaration(const NamedEnum& named_enum) {
    types::PrimitiveSubtype subtype = named_enum.enum_info.type;
    GenerateIntegerTypedef(subtype, named_enum.name);
    for (const auto& member : named_enum.enum_info.members) {
        std::string member_name = named_enum.name + "_" + NameIdentifier(member.name);
        std::string member_value;
        EnumValue(named_enum.enum_info.type, member.value.get(), library_, &member_value);
        GenerateIntegerDefine(member_name, subtype, std::move(member_value));
    }

    EmitBlank(&file_);
}

void CGenerator::ProduceInterfaceForwardDeclaration(const NamedInterface& named_interface) {
    for (const auto& method_info : named_interface.methods) {
        file_ << "#define " << method_info.ordinal_name << " ((uint32_t)"
              << method_info.ordinal << ")\n";
        if (method_info.request)
            GenerateStructTypedef(method_info.request->c_name);
        if (method_info.response)
            GenerateStructTypedef(method_info.response->c_name);
    }
}

void CGenerator::ProduceStructForwardDeclaration(const NamedStruct& named_struct) {
    GenerateStructTypedef(named_struct.c_name);
}

void CGenerator::ProduceUnionForwardDeclaration(const NamedUnion& named_union) {
    GenerateStructTypedef(named_union.name);
}

void CGenerator::ProduceInterfaceExternDeclaration(const NamedInterface& named_interface) {
    for (const auto& method_info : named_interface.methods) {
        if (method_info.request)
            file_ << "extern const fidl_type_t " << method_info.request->coded_name << ";\n";
        if (method_info.response)
            file_ << "extern const fidl_type_t " << method_info.response->coded_name
                  << ";\n";
    }
}

void CGenerator::ProduceConstDeclaration(const NamedConst& named_const) {
    // TODO(TO-702)
    static_cast<void>(named_const);

    EmitBlank(&file_);
}

void CGenerator::ProduceMessageDeclaration(const NamedMessage& named_message) {
    std::vector<CGenerator::Member> members;
    members.reserve(1 + named_message.parameters.size());
    members.push_back(MessageHeader());
    for (const auto& parameter : named_message.parameters) {
        members.push_back(CreateMember(library_, parameter));
    }

    GenerateStructDeclaration(named_message.c_name, members);

    EmitBlank(&file_);
}

void CGenerator::ProduceInterfaceDeclaration(const NamedInterface& named_interface) {
    for (const auto& method_info : named_interface.methods) {
        if (method_info.request)
            ProduceMessageDeclaration(*method_info.request);
        if (method_info.response)
            ProduceMessageDeclaration(*method_info.response);
    }
}

void CGenerator::ProduceStructDeclaration(const NamedStruct& named_struct) {
    std::vector<CGenerator::Member> members;
    members.reserve(named_struct.struct_info.members.size());
    for (const auto& struct_member : named_struct.struct_info.members) {
        members.push_back(CreateMember(library_, struct_member));
    }

    GenerateStructDeclaration(named_struct.c_name, members);

    EmitBlank(&file_);
}

void CGenerator::ProduceUnionDeclaration(const NamedUnion& named_union) {
    std::vector<CGenerator::Member> members =
        GenerateMembers(library_, named_union.union_info.members);
    GenerateTaggedUnionDeclaration(named_union.name, members);

    uint32_t tag = 0u;
    for (const auto& member : named_union.union_info.members) {
        std::string tag_name = NameUnionTag(named_union.name, member);
        auto union_tag_type = types::PrimitiveSubtype::kUint32;
        std::ostringstream value;
        value << tag;
        GenerateIntegerDefine(std::move(tag_name), union_tag_type, value.str());
        ++tag;
    }

    EmitBlank(&file_);
}

void CGenerator::ProduceInterfaceClientDeclaration(const NamedInterface& named_interface) {
    for (const auto& method_info : named_interface.methods) {
        if (!method_info.request)
            continue;
        std::vector<Member> request;
        std::vector<Member> response;
        GetMethodParameters(library_, method_info, &request, &response);
        EmitClientMethodDecl(&file_, method_info.c_name, request, response);
        file_ << ";\n";
    }

    EmitBlank(&file_);
}

void CGenerator::ProduceInterfaceClientImplementation(const NamedInterface& named_interface) {
    for (const auto& method_info : named_interface.methods) {
        if (!method_info.request)
            continue;
        std::vector<Member> request;
        std::vector<Member> response;
        GetMethodParameters(library_, method_info, &request, &response);
        EmitClientMethodDecl(&file_, method_info.c_name, request, response);
        // TODO(FIDL-162): Compute max_wr_handles.
        uint32_t max_wr_handles = 0;

        file_ << "{\n";
        file_ << kIndent << method_info.request->c_name << " _request;\n";
        // TODO(FIDL-162): Allocate message space for input strings.
        file_ << kIndent << "uint32_t _wr_num_bytes = sizeof(_request);\n";
        file_ << kIndent << "memset(&_request, 0, _wr_num_bytes);\n";
        file_ << kIndent << "_request.hdr.ordinal = " << method_info.ordinal << ";\n";
        for (const auto& member : request) {
            const auto& name = member.name;
            file_ << kIndent << "memcpy(&_request." << name << ", &" << name << ", sizeof(_request." << name << ");\n";
            // TODO(FIDL-162): Copy string data into the request.
        }
        StringView wr_handles = "NULL";
        if (max_wr_handles > 0) {
            wr_handles = "_wr_handles";
            file_ << kIndent << "zx_handle_t _wr_handles[" << max_wr_handles << "];\n";
        }
        file_ << kIndent << "uint32_t _wr_num_handles = 0u;\n";
        file_ << kIndent << "zx_status_t _status = fidl_encode(&" << method_info.request->coded_name
              << ", &_request, _wr_num_bytes, " << wr_handles << ", " << max_wr_handles
              << ", &_wr_num_handles, NULL);\n";
        // TODO(FIDL-162): Clean up handles on error.
        file_ << kIndent << "if (_status != ZX_OK)\n";
        file_ << kIndent << kIndent << "return _status;\n";
        if (!method_info.response) {
            file_ << kIndent << "return zx_channel_write(_channel, 0u, &_request, _wr_num_bytes, "
                  << wr_handles << ", _wr_num_handles);\n";
        } else {
            // TODO(FIDL-162): Compute max_rd_handles.
            uint32_t max_rd_handles = 0;

            file_ << kIndent << method_info.response->c_name << " _response;\n";
            // TODO(FIDL-162): Allocate message space for output strings.
            file_ << kIndent << "uint32_t _rd_num_bytes = sizeof(_request);\n";

            StringView rd_handles = "NULL";
            if (max_rd_handles > 0) {
                rd_handles = "_rd_handles";
                file_ << kIndent << "zx_handle_t _rd_handles[" << max_rd_handles << "];\n";
            }

            file_ << kIndent << "zx_channel_call_args_t _args = {\n";
            file_ << kIndent << kIndent << ".wr_bytes = &_request,\n";
            file_ << kIndent << kIndent << ".wr_handles = " << wr_handles << ",\n";
            file_ << kIndent << kIndent << ".rd_bytes = &_response,\n";
            file_ << kIndent << kIndent << ".rd_handles = " << rd_handles << ",\n";
            file_ << kIndent << kIndent << ".wr_num_bytes = _wr_num_bytes,\n";
            file_ << kIndent << kIndent << ".wr_num_handles = _wr_num_handles,\n";
            file_ << kIndent << kIndent << ".rd_num_bytes = _rd_num_bytes,\n";
            file_ << kIndent << kIndent << ".rd_num_handles = " << max_rd_handles << ",\n";
            file_ << kIndent << "};\n";

            file_ << kIndent << "uint32_t _actual_num_bytes = 0u;\n";
            file_ << kIndent << "uint32_t _actual_num_handles = 0u;\n";
            file_ << kIndent << "_status = zx_channel_call(_channel, 0u, ZX_TIME_INFINITE, &_args, &_actual_num_bytes, &_actual_num_handles);\n";
            // TODO(FIDL-162): Clean up handles on error.
            file_ << kIndent << "if (_status != ZX_OK)\n";
            file_ << kIndent << kIndent << "return _status;\n";

            // TODO(FIDL-162): Do we need to validate the response ordinal or does fidl_decode do that for us?
            file_ << kIndent << "_status = fidl_decode(&" << method_info.response->coded_name
                  << ", &_response, _actual_num_bytes, " << wr_handles << ", _actual_num_handles, NULL);\n";
            // TODO(FIDL-162): Clean up handles on error.
            file_ << kIndent << "if (_status != ZX_OK)\n";
            file_ << kIndent << kIndent << "return _status;\n";

            for (const auto& member : response) {
                const auto& name = member.name;
                file_ << kIndent << "memcpy(out_" << name << ", &_response." << name << ", sizeof(*out_" << name << ");\n";
                // TODO(FIDL-162): Copy string data out of the response.
            }

            file_ << kIndent << "return ZX_OK;\n";
        }
        file_ << "}\n\n";
    }
}

std::ostringstream CGenerator::ProduceHeader() {
    GeneratePrologues();

    std::map<const flat::Decl*, NamedConst> named_consts =
        NameConsts(library_->const_declarations_);
    std::map<const flat::Decl*, NamedEnum> named_enums = NameEnums(library_->enum_declarations_);
    std::map<const flat::Decl*, NamedInterface> named_interfaces =
        NameInterfaces(library_->interface_declarations_);
    std::map<const flat::Decl*, NamedStruct> named_structs =
        NameStructs(library_->struct_declarations_);
    std::map<const flat::Decl*, NamedUnion> named_unions =
        NameUnions(library_->union_declarations_);

    file_ << "\n// Forward declarations\n\n";

    for (const auto* decl : library_->declaration_order_) {
        switch (decl->kind) {
        case flat::Decl::Kind::kConst: {
            auto iter = named_consts.find(decl);
            if (iter != named_consts.end()) {
                ProduceConstForwardDeclaration(iter->second);
            }
            break;
        }
        case flat::Decl::Kind::kEnum: {
            auto iter = named_enums.find(decl);
            if (iter != named_enums.end()) {
                ProduceEnumForwardDeclaration(iter->second);
            }
            break;
        }
        case flat::Decl::Kind::kInterface: {
            auto iter = named_interfaces.find(decl);
            if (iter != named_interfaces.end()) {
                ProduceInterfaceForwardDeclaration(iter->second);
            }
            break;
        }
        case flat::Decl::Kind::kStruct: {
            auto iter = named_structs.find(decl);
            if (iter != named_structs.end()) {
                ProduceStructForwardDeclaration(iter->second);
            }
            break;
        }
        case flat::Decl::Kind::kUnion: {
            auto iter = named_unions.find(decl);
            if (iter != named_unions.end()) {
                ProduceUnionForwardDeclaration(iter->second);
            }
            break;
        }
        default:
            abort();
        }
    }

    file_ << "\n// Extern declarations\n\n";

    for (const auto* decl : library_->declaration_order_) {
        switch (decl->kind) {
        case flat::Decl::Kind::kConst:
        case flat::Decl::Kind::kEnum:
        case flat::Decl::Kind::kStruct:
        case flat::Decl::Kind::kUnion:
            // Only messages have extern fidl_type_t declarations.
            break;
        case flat::Decl::Kind::kInterface: {
            auto iter = named_interfaces.find(decl);
            if (iter != named_interfaces.end()) {
                ProduceInterfaceExternDeclaration(iter->second);
            }
            break;
        }
        default:
            abort();
        }
    }

    file_ << "\n// Declarations\n\n";

    for (const auto* decl : library_->declaration_order_) {
        switch (decl->kind) {
        case flat::Decl::Kind::kConst: {
            auto iter = named_consts.find(decl);
            if (iter != named_consts.end()) {
                ProduceConstDeclaration(iter->second);
            }
            break;
        }
        case flat::Decl::Kind::kEnum:
            // Enums can be entirely forward declared, as they have no
            // dependencies other than standard headers.
            break;
        case flat::Decl::Kind::kInterface: {
            auto iter = named_interfaces.find(decl);
            if (iter != named_interfaces.end()) {
                ProduceInterfaceDeclaration(iter->second);
            }
            break;
        }
        case flat::Decl::Kind::kStruct: {
            auto iter = named_structs.find(decl);
            if (iter != named_structs.end()) {
                ProduceStructDeclaration(iter->second);
            }
            break;
        }
        case flat::Decl::Kind::kUnion: {
            auto iter = named_unions.find(decl);
            if (iter != named_unions.end()) {
                ProduceUnionDeclaration(iter->second);
            }
            break;
        }
        default:
            abort();
        }
    }

    file_ << "\n// Simple clients \n\n";

    for (const auto* decl : library_->declaration_order_) {
        switch (decl->kind) {
        case flat::Decl::Kind::kConst:
        case flat::Decl::Kind::kEnum:
        case flat::Decl::Kind::kStruct:
        case flat::Decl::Kind::kUnion:
            // Only interfaces have client declarations.
            break;
        case flat::Decl::Kind::kInterface: {
            if (!HasSimpleLayout(decl))
                break;
            auto iter = named_interfaces.find(decl);
            if (iter != named_interfaces.end()) {
                ProduceInterfaceClientDeclaration(iter->second);
            }
            break;
        }
        default:
            abort();
        }
    }

    GenerateEpilogues();

    return std::move(file_);
}

std::ostringstream CGenerator::ProduceClient() {
    EmitFileComment(&file_);
    EmitIncludeHeader(&file_, "<lib/fidl/coding.h>");
    EmitIncludeHeader(&file_, "<string.h>");
    EmitIncludeHeader(&file_, "<zircon/syscalls.h>");
    EmitIncludeHeader(&file_, "<" + NameLibraryCHeader(library_->name()) + ">");
    EmitBlank(&file_);

    std::map<const flat::Decl*, NamedInterface> named_interfaces =
        NameInterfaces(library_->interface_declarations_);

    for (const auto* decl : library_->declaration_order_) {
        switch (decl->kind) {
        case flat::Decl::Kind::kConst:
        case flat::Decl::Kind::kEnum:
        case flat::Decl::Kind::kStruct:
        case flat::Decl::Kind::kUnion:
            // Only interfaces have client implementations.
            break;
        case flat::Decl::Kind::kInterface: {
            if (!HasSimpleLayout(decl))
                break;
            auto iter = named_interfaces.find(decl);
            if (iter != named_interfaces.end()) {
                ProduceInterfaceClientImplementation(iter->second);
            }
            break;
        }
        default:
            abort();
        }
    }

    return std::move(file_);
}

std::ostringstream CGenerator::ProduceServer() {
    return std::move(file_);
}

} // namespace fidl
